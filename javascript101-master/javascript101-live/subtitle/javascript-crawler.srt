1
00:00:01,220 --> 00:00:02,000
哈囉大家好

2
00:00:02,000 --> 00:00:04,490
歡迎來到JS程式設計新手村

3
00:00:04,670 --> 00:00:05,680
我是凱迪

4
00:00:05,820 --> 00:00:07,360
在單元29的部分

5
00:00:07,360 --> 00:00:10,130
我們將介紹NodeJS網路爬蟲的入門實戰

6
00:00:12,130 --> 00:00:14,300
這一個是我們這個單元的入門大綱

7
00:00:14,300 --> 00:00:16,840
一開始我們會介紹網路爬蟲的基本概念

8
00:00:16,840 --> 00:00:18,840
還有NodeJS的簡介

9
00:00:18,840 --> 00:00:23,510
以及網路爬蟲的基本範例的介紹

10
00:00:24,560 --> 00:00:27,080
首先介紹一下什麼是網路爬蟲的概念

11
00:00:27,280 --> 00:00:28,920
相信大家在生活當中

12
00:00:29,020 --> 00:00:32,090
已經遇過非常多網路爬蟲

13
00:00:32,090 --> 00:00:35,030
當你進到一個網站像GOOGLE

14
00:00:35,030 --> 00:00:37,920
就有一個自己的網路爬蟲

15
00:00:37,920 --> 00:00:42,220
他會把網路上所有的頁面做index

16
00:00:42,220 --> 00:00:45,720
這樣你就可以在搜尋引擎檢索到

17
00:00:45,720 --> 00:00:48,400
你自己的網路頁面

18
00:00:49,930 --> 00:00:52,600
網路爬蟲也稱為web crawler

19
00:00:52,600 --> 00:00:55,740
它具體來講就是透過寫程式

20
00:00:55,740 --> 00:01:00,390
自動化去蒐集想要存取的頁面

21
00:01:00,390 --> 00:01:05,350
它廣泛運用在非常多的地方

22
00:01:05,350 --> 00:01:08,080
接下來我們介紹一下NodeJS

23
00:01:08,080 --> 00:01:10,430
它是一個開放原始碼

24
00:01:10,430 --> 00:01:13,920
跨平台的一個執行環境

25
00:01:13,920 --> 00:01:16,610
這是什麼意思呢

26
00:01:16,610 --> 00:01:21,310
透過NodeJS可以讓你的JS執行環境

27
00:01:21,310 --> 00:01:25,200
可以脫離原來的browser這個宿主

28
00:01:25,200 --> 00:01:28,850
我們在之前介紹JS的時候有提到過

29
00:01:28,850 --> 00:01:33,360
JS是一個某種程度很依賴宿主的一個程式語言

30
00:01:33,360 --> 00:01:39,490
最早的時候JS主要是依賴在browser上面

31
00:01:39,490 --> 00:01:43,360
所以我們有很多在browser操作一些元素

32
00:01:43,360 --> 00:01:45,360
或是browser的BOM

33
00:01:45,360 --> 00:01:47,360
Browser Object Model

34
00:01:47,360 --> 00:01:53,450
去操作browser上的一些物件和方法

35
00:01:53,450 --> 00:01:56,450
那NodeJS的發展

36
00:01:56,450 --> 00:01:59,970
某種程度解放了JS的運用的環境

37
00:01:59,970 --> 00:02:02,950
讓JS打通了任督二脈

38
00:02:02,950 --> 00:02:06,700
NodeJS主要是採用Google的V8引擎

39
00:02:06,700 --> 00:02:08,810
來執行程式碼

40
00:02:08,810 --> 00:02:15,170
據說它不僅可以在伺服器端，或者是嵌入式系統

41
00:02:15,170 --> 00:02:20,400
都可以讓JS在上面執行

42
00:02:21,040 --> 00:02:24,450
除此之外NodeJS現在有非常蓬勃的生態系

43
00:02:24,450 --> 00:02:28,260
有非常多的套件

44
00:02:28,260 --> 00:02:33,950
或是開發者撰寫的一些外掛程式碼

45
00:02:33,950 --> 00:02:38,950
大部分模組都是用JS去完成的

46
00:02:40,950 --> 00:02:44,070
簡而言之，透過Node的環境

47
00:02:44,070 --> 00:02:46,320
我們可以擺脫瀏覽器束縛

48
00:02:46,320 --> 00:02:48,320
以網路爬蟲來講

49
00:02:48,320 --> 00:02:50,070
擺脫瀏覽器的束縛

50
00:02:50,070 --> 00:02:54,040
通常也可以解決一些在瀏覽器會遇到的問題

51
00:02:54,040 --> 00:03:04,230
包括同源的問題、request的一些問題

52
00:03:04,230 --> 00:03:06,640
我們透過Node環境去執行

53
00:03:06,640 --> 00:03:14,400
通常可以獲得一些簡單的解決辦法

54
00:03:15,360 --> 00:03:19,430
接下來我們透過一個簡單的實作範例

55
00:03:19,430 --> 00:03:22,720
讓大家熟悉怎麼使用NodeJS

56
00:03:22,720 --> 00:03:27,500
跟NodeJS怎麼樣去撰寫網路爬蟲

57
00:03:27,500 --> 00:03:32,820
在介紹怎麼實作NodeJS網路爬蟲之前我們要先瞭解

58
00:03:32,820 --> 00:03:35,070
在撰寫一個網路爬蟲之前




59
00:03:35,070 --> 00:03:37,360
我們要做什麼樣的準備工作

60
00:03:37,360 --> 00:03:40,680
首先，我們要先分析目標的網頁

61
00:03:40,680 --> 00:03:44,480
我們要設定我們撰寫網路爬蟲的目標

62
00:03:44,480 --> 00:03:47,330
包括說我要爬取什麼樣的資料

63
00:03:47,330 --> 00:03:51,590
有些同學可能是在投資股票

64
00:03:51,590 --> 00:03:53,590
想撰寫一些網路爬蟲

65
00:03:53,590 --> 00:03:58,850
即時監控現在股價怎麼樣、成交量怎麼樣

66
00:03:58,850 --> 00:04:03,860
股價到什麼程度的時候會希望能夠做一些進階的提醒

67
00:04:03,860 --> 00:04:07,230
包括可能寄email給你或是寄簡訊給你

68
00:04:07,230 --> 00:04:12,160
這就是一個非常簡單的應用

69
00:04:12,160 --> 00:04:13,600
如果是這樣

70
00:04:13,600 --> 00:04:19,280
target可能就是一些證交所的網站

71
00:04:19,290 --> 00:04:22,430
或是yahoo奇摩的股市

72
00:04:22,430 --> 00:04:25,920
或是網路上一些財經的網站

73
00:04:25,920 --> 00:04:27,920
所以說首先就是要設定

74
00:04:27,920 --> 00:04:32,460
你的網路爬蟲希望解決什麼樣的問題

75
00:04:32,460 --> 00:04:34,600
你需要什麼樣的目標網頁

76
00:04:34,600 --> 00:04:40,540
因為每個目標網頁都會有不同的網頁結構

77
00:04:40,540 --> 00:04:46,490
這樣你在撰寫你的網路爬蟲就會有對應不同的撰寫方式

78
00:04:46,490 --> 00:04:49,240
待會的例子

79
00:04:49,240 --> 00:04:51,820
我們會用簡單的一個網路爬蟲

80
00:04:51,820 --> 00:04:57,370
去爬取PTT的SoftJob版的文章

81
00:04:57,370 --> 00:05:01,290
我們可以在瀏覽器這邊點選

82
00:05:01,290 --> 00:05:02,800
檢視原始碼

83
00:05:02,800 --> 00:05:05,410
英文的話就是View Page Source

84
00:05:05,410 --> 00:05:09,460
這樣我們就可以檢視網頁原始碼的狀況

85
00:05:09,460 --> 00:05:12,000
我們可以看到

86
00:05:12,000 --> 00:05:14,520
html我們都有學過嘛

87
00:05:14,520 --> 00:05:16,730
像這個<a>就是超連結

88
00:05:16,730 --> 00:05:20,330
我們就可以取得這個文章

89
00:05:20,330 --> 00:05:25,630
如果說需要的話我們可以做簡單的

90
00:05:25,630 --> 00:05:28,200
文章的網路爬蟲

91
00:05:28,200 --> 00:05:34,270
可能你想要去分析批踢踢哪一類的文章比較多

92
00:05:34,270 --> 00:05:37,050
或者是說哪一種人發文最多

93
00:05:37,050 --> 00:05:41,410
哪一個id發文最多之類的去作一些分析

94
00:05:41,410 --> 00:05:48,090
或去分析說，批踢踢上文章標題怎麼去下會比較好

95
00:05:48,090 --> 00:05:50,340
之類一些進階的應用

96
00:05:50,340 --> 00:05:53,730
所以說，第一點我們分析目標網頁

97
00:05:53,730 --> 00:05:59,520
第二點我們要根據我們的目標網頁去撰寫對應的網路爬蟲程式

98
00:05:59,520 --> 00:06:01,840
撰寫網路爬蟲程式的時候

99
00:06:01,840 --> 00:06:04,110
通常我們爬取的資料

100
00:06:04,110 --> 00:06:06,400
大部分都是存在記憶體裡面

101
00:06:06,400 --> 00:06:08,670
可能是變數之類的

102
00:06:08,670 --> 00:06:10,500
存在記憶體裡面

103
00:06:10,500 --> 00:06:12,170
它有一個缺點

104
00:06:13,840 --> 00:06:17,260
缺點在於說他是揮發性的

105
00:06:17,260 --> 00:06:21,050
如果說程式結束之後

106
00:06:21,050 --> 00:06:23,750
存取的資料事實上就消失了

107
00:06:23,750 --> 00:06:30,580
所以通常我們會把這些資料存在比較持久性的資料儲存空間

108
00:06:30,580 --> 00:06:32,580
舉個例子來講像 database

109
00:06:32,580 --> 00:06:35,440
或者是檔案系統 file system

110
00:06:35,440 --> 00:06:39,670
在我們的範例中我們相對簡單一點

111
00:06:39,670 --> 00:06:42,680
我們把它存在檔案系統裡面

112
00:06:43,820 --> 00:06:48,450
在存取資料之後我們可以做一些後續加值的應用

113
00:06:48,450 --> 00:06:51,860
包括去作資料分析

114
00:06:51,860 --> 00:06:54,350
或者你可能有

115
00:06:54,350 --> 00:06:58,900
NLP的背景，就是 Natural Language Processing

116
00:06:58,900 --> 00:07:01,490
自然語言處理的經驗

117
00:07:01,490 --> 00:07:03,860
那你可以做一些斷詞斷句

118
00:07:03,860 --> 00:07:07,900
或是進一步去做 machine learning，機器學習

119
00:07:07,990 --> 00:07:09,950
或者是 data mining

120
00:07:09,950 --> 00:07:11,950
相關的一些應用

121
00:07:11,950 --> 00:07:16,590
這個就是網路爬蟲基本的一個步驟

122
00:07:16,590 --> 00:07:19,680
這是比較簡單的一個框架

123
00:07:19,680 --> 00:07:23,550
當然還有更複雜的一些處理方式

124
00:07:23,550 --> 00:07:25,550
包括還有平行處理

125
00:07:25,550 --> 00:07:28,520
或是比較複雜的一些情況

126
00:07:28,520 --> 00:07:33,300
待會我們會在再稍微提醒告訴大家

127
00:07:33,500 --> 00:07:35,940
回到我們這個實作的範例

128
00:07:35,940 --> 00:07:39,930
我們的目標就是要在 PTT SoftJob 版把文章

129
00:07:39,930 --> 00:07:44,710
跟文章的標題跟連結取得出來

130
00:07:44,710 --> 00:07:47,910
這是我們今天的一個目標

131
00:07:47,910 --> 00:07:50,610
我們使用到的工具主要有四個

132
00:07:50,610 --> 00:07:51,790
就是 NodeJS

133
00:07:51,790 --> 00:07:54,610
還有 NodeJS 的一個套件叫 request

134
00:07:54,610 --> 00:07:59,480
它主要是方便執行 HTTP 的 request

135
00:07:59,480 --> 00:08:05,430
就是幫你發出HTTP的請求給某個網站

136
00:08:05,430 --> 00:08:11,940
在這邊我們的請求就是要發給網頁版的PTT

137
00:08:11,940 --> 00:08:14,590
我們要獲得他的 response

138
00:08:14,590 --> 00:08:19,800
也就是說它會回傳 PTT SoftJob 版的網頁資料

139
00:08:19,800 --> 00:08:24,830
然後我們要去做網頁資料的篩選

140
00:08:25,490 --> 00:08:30,790
透過這樣的方式我們可以去做一些處理

141
00:08:30,790 --> 00:08:33,970
另外一個是 Cheerio

142
00:08:33,970 --> 00:08:39,420
Cheerio 是在 server side 去做類似 JQuery DOM 的處理

143
00:08:39,420 --> 00:08:46,060
在 server side 沒辦法使用像 JQuery 這樣的 library

144
00:08:46,060 --> 00:08:50,230
JQuery 的優勢是它可以讓我們很輕鬆的去操作 DOM

145
00:08:50,230 --> 00:08:52,550
因為我們的網路爬蟲在存取的時候

146
00:08:52,550 --> 00:08:55,250
有一個非常重要的概念大家要清楚

147
00:08:55,250 --> 00:08:59,900
我們會常常需要去取得我們

148
00:08:59,900 --> 00:09:02,660
讀取到的網頁元素

149
00:09:04,660 --> 00:09:09,100
這樣的話我們如果單純去寫 JS 會變的非常冗長

150
00:09:09,100 --> 00:09:13,290
我們透過這樣類似 JQuery 的 DOM 操作方式

151
00:09:13,290 --> 00:09:18,780
我們可以用非常輕鬆的方式去操作我們的 DOM

152
00:09:18,780 --> 00:09:22,720
去選擇我們想要取得的文字內容也好

153
00:09:22,720 --> 00:09:26,120
或是說我們要的元素的屬性值

154
00:09:26,120 --> 00:09:31,070
fs 是 Node 內建的檔案處理工具

155
00:09:31,070 --> 00:09:34,930
可以讓我們把我們爬取到的網頁內容

156
00:09:34,930 --> 00:09:38,210
做一些清理之後儲存成檔案格式

157
00:09:38,210 --> 00:09:43,630
以便我們未來分析和加值應用

158
00:09:44,800 --> 00:09:45,630
OK

159
00:09:45,630 --> 00:09:47,930
在真正開始我們的專案之前

160
00:09:47,930 --> 00:09:52,250
我們先完成我們的專案環境的建置

161
00:09:52,250 --> 00:09:57,000
第一個首先我們先要確認我們有安裝了 NodeJS

162
00:09:57,000 --> 00:09:59,350
如果說有學員還沒安裝的話

163
00:09:59,350 --> 00:10:01,570
你可以看 NodeJS 的官網

164
00:10:01,570 --> 00:10:06,270
我們在這邊就先安裝穩定版的版本就可以了

165
00:10:06,270 --> 00:10:10,580
點擊之後就會出現下載的頁面

166
00:10:10,580 --> 00:10:13,260
他會教你怎麼樣下載

167
00:10:13,260 --> 00:10:15,610
OK，那我們就點擊

168
00:10:17,280 --> 00:10:20,880
通常會出現一個對話框，你就依照指示下載就好了

169
00:10:20,880 --> 00:10:25,460
那我們這邊因為已經有安裝過了，所以

170
00:10:25,460 --> 00:10:28,890
我們這邊就直接來確認我們是不是有安裝成功

171
00:10:29,320 --> 00:10:31,190
我們打開我們的終端機

172
00:10:31,190 --> 00:10:36,310
如果你是 Mac 或 LIinux 使用者就在 terminal 打開就好了

173
00:10:36,310 --> 00:10:38,620
如果你是 Windows 使用者

174
00:10:38,620 --> 00:10:42,540
建議你抓 CMDER 這樣的裝置

175
00:10:42,540 --> 00:10:45,580
可以讓你更方便去打指令碼

176
00:10:45,580 --> 00:10:53,370
OK，我們在這邊確認我們的版本

177
00:10:53,760 --> 00:10:57,970
我們剛下載是 v6.9.1

178
00:10:57,970 --> 00:11:05,970
通常的話我們會用這個版本去開發我們的應用程式

179
00:11:07,300 --> 00:11:08,730
OK

180
00:11:08,730 --> 00:11:10,460
這是我們目前的版本

181
00:11:10,460 --> 00:11:11,900
之後可能會有更新的版本

182
00:11:11,900 --> 00:11:15,570
那沒關係，我們這邊就是以這個版本為標準

183
00:11:15,570 --> 00:11:17,210
OK

184
00:11:17,210 --> 00:11:20,000
首先我們要先建立一個專案資料夾

185
00:11:20,000 --> 00:11:23,750
大家過去應該都熟悉怎麼樣去建立一個資料夾了

186
00:11:23,750 --> 00:11:25,750
我們這邊再重複一次

187
00:11:25,750 --> 00:11:30,560
首先我們要先移動到你自己一個專案資料夾

188
00:11:30,560 --> 00:11:32,670
就是你可以自己建一個資料夾

189
00:11:32,670 --> 00:11:35,350
記得要知道那個命名是什麼

190
00:11:35,350 --> 00:11:37,920
那我們就可以移動到這個資料夾的位置

191
00:11:37,920 --> 00:11:42,000
在這邊我們 desktop 是桌面

192
00:11:42,000 --> 00:11:44,280
在桌面我有一個 project 資料夾

193
00:11:44,280 --> 00:11:47,400
我在 javascript101 裡面有一個 ch15

194
00:11:47,400 --> 00:11:51,780
如果說你是下載我的程式範例的話

195
00:11:51,780 --> 00:11:54,350
基本上在ch15

196
00:11:55,030 --> 00:11:59,040
我們這個範例的檔案就在裡面啦

197
00:11:59,040 --> 00:12:01,040
在這邊 examples

198
00:12:01,040 --> 00:12:02,740
這邊網路爬蟲實戰

199
00:12:02,740 --> 00:12:08,000
OK，如果說你是完全都是自己建置的也沒有關係

200
00:12:08,000 --> 00:12:15,720
那你可以用 mkdir 去建立你的檔名，這個 folder name

201
00:12:16,670 --> 00:12:18,900
然後你再移動到這個 folder name 裡面

202
00:12:20,780 --> 00:12:22,490
這樣子

203
00:12:22,890 --> 00:12:27,350
那移動進來之後，像我這邊已經移動進 ch15

204
00:12:30,280 --> 00:12:36,610
這邊我在做一個像 example1

205
00:12:37,320 --> 00:12:43,690
那在 example1 我這邊做一件事叫 npm init

206
00:12:46,200 --> 00:12:53,020
他就會說這個是要幫我們設定 package.json

207
00:12:53,020 --> 00:12:57,790
npm 就是之前有提到過 Node package management

208
00:12:57,790 --> 00:13:02,280
會幫我們去管理一些 NodeJS 的 module

209
00:13:02,640 --> 00:13:10,060
我們這邊的話名字就隨便打

210
00:13:10,640 --> 00:13:15,730
同學平常使用就可以自己再去斟酌要使用什麼

211
00:13:15,910 --> 00:13:18,270
包括就是測試的 commend 啊

212
00:13:18,270 --> 00:13:22,280
git repository 就是說如果你放到 github 上你的位置在哪

213
00:13:22,280 --> 00:13:27,690
keywords 如果說你有興趣把你的專案分享到 npm

214
00:13:27,690 --> 00:13:30,910
讓別人可以 npm install 下載的話

215
00:13:30,910 --> 00:13:35,350
你可以下一些 keywords 方便別人去搜尋

216
00:13:35,410 --> 00:13:37,070
authorrs 作者你可以打一下

217
00:13:37,070 --> 00:13:41,260
license 就是說你這個是什麼樣的 license

218
00:13:41,260 --> 00:13:44,140
這有非常多，我們這邊先用 MIT

219
00:13:44,140 --> 00:13:47,600
大家如果有興趣的話可以去研究一下 open source

220
00:13:47,840 --> 00:13:53,630
或者是相關的一些 license 的 issue

221
00:13:54,160 --> 00:13:59,830
最後就會看到說 packege.json 大概長這樣

222
00:13:59,830 --> 00:14:02,240
如果確定就打 yes

223
00:14:02,400 --> 00:14:05,450
這個跟 bower initial 是類似的

224
00:14:05,830 --> 00:14:07,360
OK

225
00:14:12,500 --> 00:14:13,950
那 Node module

226
00:14:18,110 --> 00:14:23,120
我們在 example1 這邊你就可以看到 package.json 就產生出來

227
00:14:23,120 --> 00:14:25,250
如果說你不是透過這樣的方式

228
00:14:25,250 --> 00:14:27,250
你事實上可以這樣子

229
00:14:27,250 --> 00:14:31,950
去存檔 package.json

230
00:14:31,950 --> 00:14:34,770
就是說在資料夾這邊按

231
00:14:34,770 --> 00:14:36,770
新增檔案

232
00:14:36,770 --> 00:14:42,180
那這邊這樣存就可以，但我這邊已經有，儲存的話就會把它蓋掉

233
00:14:42,650 --> 00:14:45,020
OK，因為檔名是相同的

234
00:14:45,460 --> 00:14:49,990
那我們這邊接下來要去安裝一些套件

235
00:14:50,880 --> 00:14:54,640
接下來我們要安裝我這個專案會使用到的一些套件

236
00:14:54,640 --> 00:14:57,800
同樣我們是使用 npm install

237
00:14:57,800 --> 00:15:00,640
的方式去安裝我們所需要的套件

238
00:15:00,640 --> 00:15:03,790
那--SAVE 是可以幫助我們把這個

239
00:15:03,790 --> 00:15:11,890
套件的名稱跟版本儲存到 package.json 這個設定檔

240
00:15:11,890 --> 00:15:16,240
未來如果我們想要重複使用這個專案

241
00:15:16,240 --> 00:15:23,040
可以移植到不同的電腦或平台上面再用 npm install

242
00:15:23,040 --> 00:15:28,020
就可以根據 package.json 所指示的

243
00:15:28,020 --> 00:15:30,290
套件去安裝

244
00:15:30,290 --> 00:15:32,830
那我們這邊就來安裝一下

245
00:15:32,830 --> 00:15:36,490
npm install --save request cheerio

246
00:15:36,490 --> 00:15:41,900
這樣的話我們就可以看到這個在跑在安裝套件

247
00:15:41,900 --> 00:15:43,900
我們就可以等一下

248
00:15:45,760 --> 00:15:51,600
安裝完了，warning 就不用管他，如果說沒有錯誤的話

249
00:15:51,920 --> 00:15:54,980
通常錯誤是紅字，沒有錯誤就是安裝成功了

250
00:15:55,110 --> 00:15:58,510
OK，接下來我們就可以開始我們的

251
00:15:59,440 --> 00:16:02,320
專案的網路爬蟲去撰寫了

252
00:16:02,870 --> 00:16:08,470
那如果說你有下載我們的範例程式碼，你可以

253
00:16:08,470 --> 00:16:13,820
看一下我們的範例程式，就 20 幾行的程式碼

254
00:16:14,240 --> 00:16:19,680
重點是我們要讓大家熟悉基本的 NodeJS 程式跟

255
00:16:19,810 --> 00:16:22,140
網路爬蟲的一個撰寫方式

256
00:16:41,020 --> 00:16:45,580
要特別注意的是說，我們一開始

257
00:16:45,580 --> 00:16:47,950
在 NodeJS 的環境下

258
00:16:47,950 --> 00:16:50,880
因為 NodeJS 的 module

259
00:16:50,880 --> 00:16:52,110
就是模組

260
00:16:52,110 --> 00:16:56,760
以前我們寫 JS 是比較玩具性的程式語言

261
00:16:57,100 --> 00:17:00,520
比較沒有模組化的一些概念

262
00:17:00,520 --> 00:17:02,860
所有的 JS 都寫成一張

263
00:17:02,860 --> 00:17:06,340
這樣會遇到很多難以維護的問題

264
00:17:06,340 --> 00:17:11,950
所以隨著技術的演進現在 JS 很重視模組化的開發

265
00:17:12,910 --> 00:17:15,300
像是怎麼樣去引入模組

266
00:17:16,420 --> 00:17:19,200
或者是把你的模組輸出讓別人使用

267
00:17:19,200 --> 00:17:20,710
這是非常重要的一個概念

268
00:17:20,710 --> 00:17:23,200
那也出現很多樣的標準

269
00:17:23,200 --> 00:17:27,150
在 NodeJS 是遵循一個叫 CommonJS 的規範

270
00:17:27,150 --> 00:17:30,330
你可以去參考這一個說明

271
00:17:34,800 --> 00:17:37,340
最簡單的講法我們可以看

272
00:17:37,340 --> 00:17:41,790
如果你要使用一個模組可以用 require 的方式

273
00:17:42,930 --> 00:17:45,680
當然未來的話可以支援更多的

274
00:17:45,680 --> 00:17:49,420
像 ES6 是 import 的方式

275
00:17:58,480 --> 00:18:04,840
這是 ES6 版本的模組化的使用方式

276
00:18:04,840 --> 00:18:10,160
在我們這邊因為 NodeJS 版本慢慢演進

277
00:18:10,160 --> 00:18:14,380
有些還沒有完全支援 ES6 的一些特性

278
00:18:14,380 --> 00:18:16,840
所以我們這邊就用 CommonJS 的作法

279
00:18:16,840 --> 00:18:20,050
Common 的作法通常就是

280
00:18:20,050 --> 00:18:23,090
要使用模組就用 require 的方式

281
00:18:23,090 --> 00:18:27,820
在下個單元我們會更多地去探討模組化的一些

282
00:18:27,820 --> 00:18:28,580
CommonJS的用法

283
00:18:28,580 --> 00:18:32,360
包括你要輸出你的模組給別的檔案去使用

284
00:18:32,360 --> 00:18:34,360
這個我們在下個單元會去講到

285
00:18:34,360 --> 00:18:36,360
那我們這邊先記憶的是說

286
00:18:36,360 --> 00:18:39,760
在 NodeJS、CommonJS 規範的作法是說

287
00:18:39,760 --> 00:18:42,040
我們要使用模組的話就要使用 require

288
00:18:42,340 --> 00:18:46,690
我們這邊已經有 download request 跟 cheerio

289
00:18:46,690 --> 00:18:48,690
這有兩個模組

290
00:18:48,690 --> 00:18:51,210
我們這邊就是把它載入進來

291
00:18:51,210 --> 00:18:54,320
丟給 cheerio 跟 request 這兩個常數

292
00:18:54,910 --> 00:18:59,160
那 fs 是內建的一個模組我們就不用安裝了

293
00:18:59,390 --> 00:19:04,020
所以說他就是可以讓你做一個檔案操作處理的部分

294
00:19:05,120 --> 00:19:07,680
那我們這邊來看一下 cheerio

295
00:19:08,990 --> 00:19:12,900
事實上你可以在網路上去找

296
00:19:12,900 --> 00:19:16,180
像 Github 上面這就是 request 的一個 repository

297
00:19:16,180 --> 00:19:20,690
除了我們之前講的在 npm 上面我們用 npm install

298
00:19:20,690 --> 00:19:23,710
可以在 npm 裡面去找

299
00:19:23,710 --> 00:19:26,880
這一個 module 的詳細介紹

300
00:19:26,880 --> 00:19:28,880
也可以直接進來 Github 去看

301
00:19:28,880 --> 00:19:31,160
上面就有教你怎麼樣的使用方法

302
00:19:31,260 --> 00:19:33,290
就是說引入模組

303
00:19:33,290 --> 00:19:36,010
使用這個 request 的一個方法

304
00:19:36,010 --> 00:19:37,650
這個前面釋放他的網址

305
00:19:37,650 --> 00:19:38,930
後面是 callback function

306
00:19:38,930 --> 00:19:40,480
Callback function 是什麼呢？就是說

307
00:19:40,480 --> 00:19:44,200
當你資料回傳之後要去做什麼樣的一個處理

308
00:19:45,040 --> 00:19:49,720
他這個 callback function 自帶了三個參數

309
00:19:49,720 --> 00:19:51,720
error、response 跟 body

310
00:19:51,720 --> 00:19:55,740
response 主要是 http response

311
00:19:55,740 --> 00:20:00,300
這邊他的屬性值其中一個叫 status code

312
00:20:00,300 --> 00:20:04,280
他可能回傳 200、404、500

313
00:20:04,280 --> 00:20:09,090
你可以判斷說回傳 200 是正確的

314
00:20:09,090 --> 00:20:11,090
的話你要去做什麼事

315
00:20:11,090 --> 00:20:14,010
或是說，這個是比較安全的寫法

316
00:20:14,010 --> 00:20:17,250
你 !error 然後 && 是且

317
00:20:17,250 --> 00:20:20,560
且你 status code 是 200

318
00:20:20,560 --> 00:20:25,600
如果你忘記 http code 可以去查一下

319
00:20:27,262 --> 00:20:30,220
因為這個比較偏向說

320
00:20:30,220 --> 00:20:33,180
維基百科打開就可以看到

321
00:20:33,180 --> 00:20:37,180
你在做一些 web 的應用會常常看到

322
00:20:37,180 --> 00:20:40,880
一些 http 的 code 像 1xx 是什麼意思

323
00:20:40,880 --> 00:20:46,620
2xx 是代表成功類，3xx 是代表重新導向

324
00:20:46,620 --> 00:20:50,440
4xx 是用戶端的一些錯誤

325
00:20:50,440 --> 00:20:53,380
可能是沒有這個檔案或授權失敗

326
00:20:53,380 --> 00:20:57,100
404 應該是大家最常看到的，就是 Not found

327
00:20:57,100 --> 00:20:59,880
500 的話就是伺服器端的一些錯誤

328
00:20:59,880 --> 00:21:01,680
根據這些 status code 的錯誤

329
00:21:01,680 --> 00:21:04,900
你可以去判斷說要怎樣去接下你的程式

330
00:21:04,900 --> 00:21:08,300
要做怎麼樣的錯誤處理

331
00:21:10,220 --> 00:21:14,460
這個 body 就是說我們去取得 google.com 這個

332
00:21:14,700 --> 00:21:17,920
網頁回傳的內容

333
00:21:17,920 --> 00:21:22,160
會秀出他整張的 html

334
00:21:23,040 --> 00:21:26,260
有沒有覺得很方便這個 request 就幫你處理好

335
00:21:26,260 --> 00:21:30,360
你只要四行程式碼就可以取得你要取的這個網頁的

336
00:21:30,580 --> 00:21:32,420
一張 html 就讀進來了

337
00:21:32,420 --> 00:21:36,800
但讀進來這一整張你還要做一些處理

338
00:21:36,800 --> 00:21:40,780
因為我們不是要一整張 html 那麼多的 tag

339
00:21:40,780 --> 00:21:46,200
我們是要去裡面淘金把有價值的東西取出來

340
00:21:46,200 --> 00:21:48,940
這個就是要用到 cheerio 了

341
00:21:48,940 --> 00:21:50,420
事實上他還有一些 pipe line

342
00:21:50,420 --> 00:21:55,940
就是說我們取得之後要去做什麼串連，去做什麼事情

343
00:21:55,940 --> 00:21:57,940
或是說監聽一些事件

344
00:21:58,700 --> 00:22:02,480
等等很多更進一步的應用

345
00:22:02,480 --> 00:22:07,380
或是說你想要用 forms，想要提交表單

346
00:22:07,380 --> 00:22:10,700
你可能每次要去登入非常麻煩

347
00:22:10,700 --> 00:22:14,140
你可以用這樣的方式去送出 post

348
00:22:14,140 --> 00:22:17,340
可能登入登出都是用 post

349
00:22:17,340 --> 00:22:21,520
剛剛的取得網頁事實上是用 get 方式

350
00:22:21,520 --> 00:22:27,140
這樣的話你用指令碼的方式就可以去做登入網站

351
00:22:27,140 --> 00:22:32,160
你要附加你的一些帳戶的資訊

352
00:22:32,160 --> 00:22:36,140
或是說你要去做一些什麼動作

353
00:22:36,140 --> 00:22:41,540
更甚者你可以做一些網路爬蟲去幫你買票

354
00:22:41,540 --> 00:22:48,120
或是說去幫你偵測比價之類的應用方式

355
00:22:48,120 --> 00:22:49,840
有非常多

356
00:22:50,340 --> 00:22:53,360
所以這些網路爬蟲的世界，最重要的是說

357
00:22:53,640 --> 00:22:56,420
你的想像力的空間

358
00:22:56,420 --> 00:22:58,460
在這邊我們 cheerio 的話

359
00:22:58,460 --> 00:23:02,960
我們可以去做 DOM 的一些操作

360
00:23:04,440 --> 00:23:08,720
那我們在安裝完 cheerio 的模組的話

361
00:23:08,720 --> 00:23:14,160
我們這邊可以用 require 把 cheerio 操作出來

362
00:23:14,680 --> 00:23:16,980
我們可以把 cheerio 載入出來

363
00:23:17,760 --> 00:23:20,940
這邊可以看一下就是說

364
00:23:20,940 --> 00:23:25,240
當你把 request body 載入進來之後

365
00:23:25,240 --> 00:23:29,800
你可以用 load 這個方法把它載入到變數裡面

366
00:23:29,900 --> 00:23:34,080
這樣我們就可以透過類似 jQuery 的方式去做操作

367
00:23:34,300 --> 00:23:38,960
tags 就是可以把 tags 取得出來

368
00:23:38,960 --> 00:23:43,580
當然你也可以類似 jQuery 的操作去操作你的 CSS

369
00:23:44,120 --> 00:23:46,820
當然有很多的應用

370
00:23:46,820 --> 00:23:51,100
這邊可以講一些我們後續的一些應用

371
00:23:51,140 --> 00:23:57,560
大致上很多人對怎麼樣去引入模組、操作模組會有一些想法

372
00:23:57,560 --> 00:24:02,180
我們這邊就接下來我們的應用程式

373
00:24:02,180 --> 00:24:04,040
我們這邊就用 request

374
00:24:04,040 --> 00:24:10,920
request 這邊除了放 url 以外可以放一個 object

375
00:24:10,920 --> 00:24:14,800
這個 object 可以設定我們的 key/value

376
00:24:14,800 --> 00:24:18,300
url 是我們要讀取的網頁

377
00:24:18,300 --> 00:24:21,520
math 我們要用 get 方法

378
00:24:21,520 --> 00:24:25,460
你也可以用 post 方法，這個我們之前有講過了

379
00:24:25,460 --> 00:24:29,180
function 就是 call back function

380
00:24:29,180 --> 00:24:32,240
第一個是 error 的 function，當你 error 要做什麼事情

381
00:24:32,240 --> 00:24:35,120
我們這邊就只簡單地處理

382
00:24:35,480 --> 00:24:39,640
error 的話我們就印出錯誤訊息然後 return

383
00:24:39,640 --> 00:24:41,080
不要往下執行

384
00:24:41,080 --> 00:24:46,240
要注意的是說當你一個程式有 return 值的話

385
00:24:46,240 --> 00:24:49,180
就不會再往下執行下去了

386
00:24:49,180 --> 00:24:52,000
body 是我們這邊要處理的內容

387
00:24:52,000 --> 00:24:56,940
cheerio load body 進來我們這邊就可以去做一些

388
00:24:56,940 --> 00:24:59,820
DOM 操作的處理

389
00:25:02,900 --> 00:25:08,740
接下來把 body 內容讀取進來後要做一些處理

390
00:25:08,740 --> 00:25:14,840
首先 body 內容讀取進來後，我們給一個常數 $

391
00:25:14,840 --> 00:25:17,480
這個是方便使用

392
00:25:17,480 --> 00:25:21,720
我們把它假設成我們可以在 server side 操作 DOM

393
00:25:21,720 --> 00:25:23,680
也就是類似 jQuery 的感覺

394
00:25:23,680 --> 00:25:26,780
jQuery 的標準符號就是 $

395
00:25:26,780 --> 00:25:28,780
那我們救用 $ 來表示

396
00:25:28,780 --> 00:25:33,940
我們在 app.js 裡面還要宣告

397
00:25:33,940 --> 00:25:47,240
results 把他宣告成常數也可以

398
00:25:47,240 --> 00:25:52,080
這邊會用 push 去做一些操作

399
00:26:00,120 --> 00:26:04,180
那我們先來看一下這個結果

400
00:26:15,440 --> 00:26:17,360
先移動回來

401
00:26:17,360 --> 00:26:23,900
剛剛 example 1 主要是讓大家熟悉怎麼樣透過 npm 的 initial

402
00:26:23,900 --> 00:26:28,700
怎麼建置 package.json 或是手動建置

403
00:26:28,700 --> 00:26:31,000
教大家怎麼 npm install

404
00:26:31,720 --> 00:26:33,080
怎麼建資料夾之類的

405
00:26:33,080 --> 00:26:39,340
那我們這邊回到在 Github 上的範例

406
00:26:39,340 --> 00:26:41,240
這個是已經寫好啦，沒關係

407
00:26:41,240 --> 00:26:44,020
我們這邊帶大家一起走

408
00:26:44,640 --> 00:26:49,340
在執行一個 NodeJS 程式最簡單的方法就是 node

409
00:26:49,340 --> 00:26:54,920
然後後面那個檔名，這樣就可以透過這個方式去執行 node 程式

410
00:27:03,520 --> 00:27:07,440
這個就是我們的…大家可以看到好熟悉喔

411
00:27:07,440 --> 00:27:11,900
「[請益] 關於第一份工作的取捨」

412
00:27:18,240 --> 00:27:22,700
我們這邊就是要講解說這個程式到底怎麼做的

413
00:27:22,700 --> 00:27:28,000
我們發現這邊多一個 result 檔案，那這是什麼呢？

414
00:27:30,280 --> 00:27:34,100
網路爬蟲第一個動作就是分析你要爬的網頁

415
00:27:34,100 --> 00:27:37,800
我們這邊是批踢踢的 SoftJob 板

416
00:27:37,800 --> 00:27:40,920
它大概的結構是長什麼樣子的？

417
00:27:40,920 --> 00:27:45,360
我們撰寫網路爬蟲程式，把資料儲存起來

418
00:27:45,360 --> 00:27:47,700
當然未來我們可以去做一些加值服務

419
00:27:47,700 --> 00:27:52,120
我們可以去分析什麼樣的標題

420
00:27:52,120 --> 00:27:56,420
是什麼樣的人發的之類的

421
00:27:56,420 --> 00:28:02,520
我們這邊先不做那麼複雜

422
00:28:02,520 --> 00:28:06,640
我們接下來講，這邊 $ 是讀出來的 body

423
00:28:06,640 --> 00:28:14,700
我們可以在 NodeJS 環境去用 console.log

424
00:28:14,700 --> 00:28:21,080
我們講過 NodeJS 是脫離 browser 的宿主

425
00:28:21,080 --> 00:28:27,980
console.log 他會顯示在這個 terminal 裡面

426
00:28:27,980 --> 00:28:39,660
這一張事實上就是批踢踢 SoftJob 板的

427
00:28:39,660 --> 00:28:46,900
web ptt 大家還有印象嗎？ view page source 到這邊

428
00:28:47,700 --> 00:28:50,400
他的整張網頁就被我們爬下來了

429
00:28:50,400 --> 00:28:54,060
有沒有很高興的感覺？

430
00:28:54,060 --> 00:28:58,600
這樣你事實上就會寫怎麼樣用 NodeJS 寫網路爬蟲

431
00:28:58,600 --> 00:29:03,680
那有更複雜更進階的應用，我們這邊先講基礎

432
00:29:03,680 --> 00:29:10,020
未來大家有更多創意或想法再提出來一起討論

433
00:29:10,020 --> 00:29:17,280
這個載進來我們做一件事情就是說選取 a

434
00:29:17,280 --> 00:29:21,840
這好像 jQuery 選擇器

435
00:29:21,840 --> 00:29:27,240
這邊 a 就是文章連結都是 <a> 

436
00:29:27,240 --> 00:29:31,360
事實上要做一些 filtering，我們這邊就先不做了

437
00:29:31,360 --> 00:29:37,420
就讓大家先熟悉怎麼操作

438
00:29:38,300 --> 00:29:40,780
我們這邊先把超連結都取得出來

439
00:29:40,780 --> 00:29:48,780
這邊，先把這些都清掉才不會有太多雜訊

440
00:29:56,180 --> 00:29:58,840
再執行我們的程式

441
00:29:58,840 --> 00:30:10,720
你會發現，這個就是我們取出來每一個每一個的元素

442
00:30:10,720 --> 00:30:12,860
第 0 個的話

443
00:30:12,860 --> 00:30:15,540
他 tag name 是 a，就是超連結嘛

444
00:30:15,540 --> 00:30:17,140
他有什麼 attribute 呢？

445
00:30:17,140 --> 00:30:20,580
logo attribute 這是我們等一下會取的東西

446
00:30:20,580 --> 00:30:24,380
他有什麼 children 接下來下一個元素是什麼

447
00:30:24,380 --> 00:30:28,500
前一個元素是什麼，他的祖先元素

448
00:30:28,500 --> 00:30:30,160
父親元素是什麼

449
00:30:30,160 --> 00:30:35,340
你會發現 DOM 操作變非常簡單，一行程式碼就幫你取得

450
00:30:35,340 --> 00:30:42,020
所有符合 name 是 a 的元素都幫你取出來了

451
00:30:45,260 --> 00:30:47,040
接下來我們要做一件事情就是說

452
00:30:47,040 --> 00:30:52,320
我們要把所有的文章的標題跟文章的連結

453
00:30:52,320 --> 00:30:55,380
把它塞到 results 這個 arry裡面

454
00:30:56,520 --> 00:31:03,420
Array 就是可以儲存一個

455
00:31:05,740 --> 00:31:08,360
資料的資料結構

456
00:31:08,360 --> 00:31:12,380
我們這邊的資料結構是長這樣啦

457
00:31:16,340 --> 00:31:24,600
是儲存很多個 objects 的一個 array

458
00:31:35,020 --> 00:31:39,460
還有其他的，這樣子一直下去

459
00:31:39,960 --> 00:31:42,880
那這是我們的資料結構

460
00:31:42,880 --> 00:31:49,960
這種物件、陣列，都是一種資料結構，跟 function 不一樣

461
00:31:49,960 --> 00:31:53,920
Function 主要是重複執行的程式碼

462
00:31:53,920 --> 00:32:00,780
資料結構是方便我們資料存取跟操作，這兩個是不一樣的概念

463
00:32:01,560 --> 00:32:06,960
我們這邊是用到 array 的方法叫 push，內建的

464
00:32:06,960 --> 00:32:13,460
如果大家不熟的話可以到 MDN 裡面去找

465
00:32:18,800 --> 00:32:22,560
到網路上找 javascript push

466
00:32:22,560 --> 00:32:28,760
他就會講說 push 會幫你把一個或多個元素放到陣列末端

467
00:32:28,760 --> 00:32:31,360
Array 是一種資料結構啦

468
00:32:31,360 --> 00:32:46,620
這邊就把push，跑一個 for loop，initial 的變數是 0

469
00:32:46,620 --> 00:32:50,440
i 如果小於 titiles.length

470
00:32:50,440 --> 00:32:57,560
titles.length 就是說我所有符合元素是 a 的到底有多長

471
00:32:57,560 --> 00:33:04,820
那我們是從零開始，所以假設有 3 個元素好了

472
00:33:04,820 --> 00:33:11,960
假設 titles.length 是 3，他會存到 0 1 2

473
00:33:11,960 --> 00:33:14,800
0 1 2，這樣還是 3 個元素嘛

474
00:33:14,800 --> 00:33:19,760
因為我們這邊設定的條件是說當小於才會執行

475
00:33:19,760 --> 00:33:25,800
如果說等於的話就會跳出去

476
00:33:25,800 --> 00:33:31,920
我們講過程式語言 index 建議，算約定俗成的觀念

477
00:33:31,920 --> 00:33:36,640
index 會從 0 開始

478
00:33:36,640 --> 00:33:41,080
我們就 0 1 2，總長度是 3

479
00:33:41,080 --> 00:33:45,460
當 i 小於這個長度，就是 i < 3 的話

480
00:33:45,460 --> 00:33:51,800
那 i 就會 ++，++ 之後就會去執行裡面

481
00:33:51,800 --> 00:33:57,140
執行完後再會去判斷是不是還是小於三

482
00:33:57,780 --> 00:34:00,860
如果已經大於 3 就會跳出這個迴圈了

483
00:34:00,860 --> 00:34:03,760
這個就是 for-loop 的應用 

484
00:34:03,760 --> 00:34:07,040
所以說這個 push 裡面的話

485
00:34:07,040 --> 00:34:14,560
我們這邊也是用 cheerio 的一個方法，大家可以去看

486
00:34:14,560 --> 00:34:20,620
cheerio 可以用 tags 去取得它的內容

487
00:34:20,620 --> 00:34:38,180
我這邊 titles 根據不同的值

488
00:34:42,700 --> 00:34:48,260
這邊是一個大物件

489
00:34:48,260 --> 00:34:52,600
所以他的 key 都是 index 值

490
00:34:52,600 --> 00:34:58,320
這邊 key 是 0，就會對應到這邊有一個 object

491
00:34:58,320 --> 00:35:09,600
取出來，所以 titles[0] 就會取出第一個 a 的物件

492
00:35:09,600 --> 00:35:16,040
很抽象嗎？那我們來看這邊選一個好了

493
00:35:16,040 --> 00:35:20,400
最後一個就是什麼社群活動免費分享

494
00:35:20,400 --> 00:35:33,500
他的 index 假設是 30 我就取到這個物件的所有內容

495
00:35:33,500 --> 00:35:42,200
我不再用 tags 這個方法，取得我想要的元素

496
00:35:42,200 --> 00:35:49,100
我今天是 titles 第 30 個元素的標題，text 就是標題把它取出來

497
00:35:49,100 --> 00:35:53,700
這個如法炮製，attr 這個方法是說你要取得哪一個 attribute

498
00:35:53,700 --> 00:35:58,966
可以看到它 attribute 有幾種，有 href

499
00:35:58,960 --> 00:36:03,933
href 就是超連結的連結位址

500
00:36:03,930 --> 00:36:08,566
那我這邊就把 SoftJob 的文章的位址取出來了

501
00:36:08,560 --> 00:36:15,133
也就是說這就會符合我們設計的 object 是 title、link 這樣

502
00:36:15,133 --> 00:36:17,130
把它 push 到一個 array

503
00:36:17,130 --> 00:36:21,266
最後我們希望把這個檔案存起來

504
00:36:21,260 --> 00:36:24,633
把爬取的網頁內容存起來

505
00:36:24,630 --> 00:36:27,733
用 fs 這個 module 

506
00:36:27,730 --> 00:36:31,900
他有一個方法叫 writeFileSync

507
00:36:31,900 --> 00:36:37,800
是說有 synchronous 就是可能有 asynchronous

508
00:36:37,800 --> 00:36:39,800
確實就是有 asynchronous

509
00:36:39,800 --> 00:36:46,466
你可以看 NodeJS file system 的 document 就都有寫

510
00:36:49,033 --> 00:36:55,000
或者你用 google 的方式也可以

511
00:36:55,000 --> 00:37:00,466
這個就是 file name，然後要存什麼資料

512
00:37:00,460 --> 00:37:05,066
然後有什麼樣的 encoding 就是編碼

513
00:37:05,060 --> 00:37:08,666
那我們這邊是同步處理

514
00:37:08,660 --> 00:37:13,533
當然也有非同步處理我們之前有講過它不是循序漸進的

515
00:37:13,530 --> 00:37:20,866
通常會搭配 callback function 去做後面的處理 

516
00:37:20,860 --> 00:37:27,033
那我們這邊就是簡單循序一步一步的完成

517
00:37:27,030 --> 00:37:31,300
不是非同步的去做處理

518
00:37:31,300 --> 00:37:42,200
這邊就是 result.json ，我們等下一跑 app.js 就會寫檔進去

519
00:37:42,200 --> 00:37:44,833
那後面這個就是我們抓取下來的網頁

520
00:37:44,830 --> 00:37:50,066
但是因為他是 object 檔案，但我們想把它轉成 json 檔案

521
00:37:50,060 --> 00:37:56,100
所以這邊有內建的 JSON.stringify 的方法

522
00:37:56,100 --> 00:38:03,200
如果你不熟悉，在 MDN 有一個 JSON，是 build-in 的一個 object

523
00:38:03,200 --> 00:38:06,066
他有兩個方法：parse 跟 stringify

524
00:38:06,060 --> 00:38:10,133
parse 就是 stringify 的相反

525
00:38:10,130 --> 00:38:21,166
它把 json 轉成 javascript 可以使用的 value 或物件

526
00:38:21,160 --> 00:38:28,066
我們還記得 json 格式是 key/value，跟雙引號去處理

527
00:38:28,060 --> 00:38:34,933
parse 就可以轉換成 javascript 的物件

528
00:38:34,930 --> 00:38:39,833
所以 javascript 很常在 json 跟物件之間轉換

529
00:38:39,833 --> 00:38:41,830
那我們這邊來看

530
00:38:41,830 --> 00:38:48,966
我們的物件是長這樣，跟標準 json 不一樣

531
00:38:48,960 --> 00:38:51,433
標準 json 是要雙引號雙引號雙引號

532
00:38:51,430 --> 00:39:00,633
我們這邊可以把物件轉成標準 json 的格式

533
00:39:00,630 --> 00:39:08,566
我們這邊是要把它轉換成這樣的模式，最後把它寫檔進去

534
00:39:08,560 --> 00:39:16,766
結果就是會像我們這樣呈現，檔案就寫出來啦

535
00:39:16,760 --> 00:39:26,400
title、批踢踢，原本的物件被我們寫成 json 檔案

536
00:39:27,033 --> 00:39:39,300
如果這邊還不清楚的話，可以把 console.log

537
00:39:41,666 --> 00:39:48,366
這個跟剛剛那個不太一樣，title 沒有雙引號

538
00:39:48,366 --> 00:39:50,360
就是一個物件的格式

539
00:39:50,360 --> 00:39:53,333
就是 javascript 的物件

540
00:39:53,330 --> 00:39:58,100
透過 stringify 的方式我們就可以把它轉成 json 格式

541
00:39:58,100 --> 00:40:03,300
如果說你未來想要把它變成一個 api，那用 json 格式是相對比較好的

542
00:40:03,300 --> 00:40:08,433
那這個單元我們範例大致是這樣子

543
00:40:08,430 --> 00:40:12,066
還有一些進階議題

544
00:40:12,166 --> 00:40:21,566
throttling 意思是說有些網站管理員或服務的維護者它會去

545
00:40:21,560 --> 00:40:23,933
抵擋一些網路的爬蟲

546
00:40:23,930 --> 00:40:28,266
畢竟網路爬蟲如果量很大會消耗他的一些系統資源

547
00:40:28,260 --> 00:40:31,500
所以他通常會降低同源

548
00:40:34,133 --> 00:40:39,066
origin policy，這其實是為了要保護一些資訊安全議題

549
00:40:39,060 --> 00:40:47,866
那在瀏覽器會去保護你的一些 request 是要 same origin

550
00:40:47,860 --> 00:40:55,833
什麼是 origin？例如說兩份網頁具相同協定跟 port 跟主機位置

551
00:40:55,830 --> 00:41:02,733
下面列出就是說跟這串網頁同源的是哪些

552
00:41:02,730 --> 00:41:07,066
這個不同源，為什麼呢？這個協定不一樣，他是 https

553
00:41:07,066 --> 00:41:09,060
這個是 http，就不同源

554
00:41:09,060 --> 00:41:13,966
那這個 port 不樣，他是 81 port，那一般 http 是 80 port

555
00:41:13,966 --> 00:41:15,960
所以 port 不一樣就不同源

556
00:41:15,960 --> 00:41:22,266
那主機位置不一樣，你發現他這個 sub domian 是不一樣的

557
00:41:22,260 --> 00:41:26,100
sub domain 就是說他主要 domain 之前還有一個 sub domain

558
00:41:26,100 --> 00:41:28,733
像什麼 blog.xxx

559
00:41:28,730 --> 00:41:34,133
或是說 news.xxx 這邊是 store 跟 news 不一樣

560
00:41:34,130 --> 00:41:36,200
所以這邊是不一樣的來源

561
00:41:36,200 --> 00:41:39,766
一般在 browser 裡面會有這個 issue 

562
00:41:39,760 --> 00:41:46,900
就是說你跨 origin 去做 request 會有一些問題

563
00:41:46,900 --> 00:41:53,833
我們這邊透過 NodeJS 可以規避這樣的 issue

564
00:41:53,830 --> 00:42:00,100
透過這個 request 就可以盡量去規避這個 issue

565
00:42:00,100 --> 00:42:04,966
那如果說遇到這樣的問題就比較麻煩一點

566
00:42:04,960 --> 00:42:11,533
就是說你可能要用 random ip 或 slip 避免讓你看起來像個爬蟲

567
00:42:11,530 --> 00:42:21,500
去規避管理員阻止你去爬取網頁的一些行為

568
00:42:21,500 --> 00:42:26,200
但是我們在進行網路爬蟲有一些網路爬蟲禮節

569
00:42:26,200 --> 00:42:29,733
大家盡量要去遵守，包括不要一次太多 request

570
00:42:29,730 --> 00:42:33,600
要休息跟幾秒，這都是基本的禮節，大家要注意一下

571
00:42:33,600 --> 00:42:38,300
那 cookie 就是說

572
00:42:38,300 --> 00:42:44,000
有些網站可能需要你要釋出 cookie 他才能讓你去讀取

573
00:42:44,000 --> 00:42:47,400
這可能就要多個 request 先去取 cookie

574
00:42:47,400 --> 00:42:52,200
然後再把這些 cookie 放在你 request http 的參數

575
00:42:52,200 --> 00:42:54,100
去做下一步的 request

576
00:42:54,100 --> 00:43:00,066
或是說有些會直接擋掉 bots，所以你要偽裝成像真人一樣

577
00:43:00,060 --> 00:43:06,133
或是說他可能需要 reCAPTCHA

578
00:43:06,130 --> 00:43:10,866
有些需要你要說我不是機器人、或是 reCAPTCHA

579
00:43:10,860 --> 00:43:14,933
就是輸入英文單字之類的

580
00:43:14,930 --> 00:43:20,900
回答問題，有些是比較難處理，大家可以去網路上找進階解法

581
00:43:20,900 --> 00:43:23,366
或是說 javascript 一些動態載入頁面

582
00:43:23,360 --> 00:43:28,500
可能就是要去使用像 phantomjs 這樣的 tool 

583
00:43:28,500 --> 00:43:30,633
去讓你可以讀取

584
00:43:30,630 --> 00:43:38,666
因為現在很多網頁都用 js ajax 去比較 dynamic 去 loading 它的資料

585
00:43:38,660 --> 00:43:44,766
這是什麼意思？像這個就非常簡單他是用 server 的 rendering

586
00:43:44,760 --> 00:43:52,300
可是有些網站你檢視原始碼一整張可能是空白的

587
00:43:52,300 --> 00:43:55,033
你根本就看不到他的網頁元素是什麼

588
00:43:55,030 --> 00:43:58,733
他很有可能就是用 javascript 去 loading 他的頁面

589
00:43:58,730 --> 00:44:03,566
這樣的話你用傳統的網路爬蟲就不行

590
00:44:03,560 --> 00:44:08,066
你要用 phantomjs 或 CasperJS 的方式去處理

591
00:44:08,060 --> 00:44:14,400
網路上有非常多的資源是網路爬蟲的介紹，大家可以參考一下

592
00:44:14,400 --> 00:44:21,333
這個單元中我們介紹了網路爬蟲概念，和 NodeJS 開發環境的介紹跟使用

593
00:44:21,330 --> 00:44:24,166
網路爬蟲我們介紹了一個簡單的單元案例

594
00:44:24,160 --> 00:44:26,900
希望大家會喜歡，我們下個單元見囉，掰掰！

